%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Wenneker Article
% LaTeX Template
% Version 2.0 (28/2/17)
%
% This template was downloaded from:
% http://www.LaTeXTemplates.com
%
% Authors:
% Vel (vel@LaTeXTemplates.com)
% Frits Wenneker
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[10pt, a4paper, twocolumn]{article} % 10pt font size (11 and 12 also possible), A4 paper (letterpaper for US letter) and two column layout (remove for one column)

\input{structure.tex} % Specifies the document structure and loads requires packages

%----------------------------------------------------------------------------------------
%	ARTICLE INFORMATION
%----------------------------------------------------------------------------------------

\title{Introduction to Nim} % The article title

\author{
	\authorstyle{Boitumelo Phetla} % Authors
	\newline\newline % Space before institutions
	\textsuperscript{1}\institution{General-purpose Programming Language}\\ % Institution 1
}

% Example of a one line author/institution relationship
%\author{\newauthor{John Marston} \newinstitution{Universidad Nacional Autónoma de México, Mexico City, Mexico}}

\date{\today} % Add a date here if you would like one to appear underneath the title block, use \today for the current date, leave empty for no date

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Print the title

\thispagestyle{firstpage} % Apply the page style for the first page (no headers and footers)

%----------------------------------------------------------------------------------------
%	ABSTRACT
%----------------------------------------------------------------------------------------

\lettrineabstract{Nim is unique. It is multi-paradigm, general purpose programming language with syntax like Python. However, the language or the design of this programming language does not emphasize on Object Oriented Programming style/concept. The language follows its own programming styling, it is imperative that its syntax styling is kept as guided by Nim's reference manual. Nim focuses mainly on effiency, expressiveness, and elegance. Nim is much like any other programming language with features such as concurrency, parallelism, user-defined types, the standard library, and more. Nim also has Nim's specific features such as asynchronous input/output, metaprogramming, and the foreign function interface.}

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\section{What is Nim?}

\begin{figure}[hbt!]
	\includegraphics[width=0.25\linewidth]{Nim.png} % Figure image
	%\caption{Nim} % Figure caption
	\label{nim} % Label for referencing with \ref{bear}
\end{figure}

Impatience is my vice, I want to know I have the right tools for the job before I commit. So what does this mean?
\\
\\
\textbf{\href{https://exercism.io/tracks/nim/installation}{How to install Nim}}
\\
\begin{lstlisting}
$bash: brew install nim

==> Pouring nim-0.19.4.mojave.bottle.tar.gz
/usr/local/Cellar/nim/0.19.4: 411 files, 12.8MB
\end{lstlisting}
\newpage
\textbf{Simple Script}
\\
\\
Create file hello\_world.nim
\begin{lstlisting}
#simple comment line
echo "Hello world!"
\end{lstlisting}
\\
\\
\textbf{Compile Script}
\\
\\
Compile hello\_world.nim
\begin{lstlisting}
$bash: nim compile --run hello_world.nim
Hint: used config file '/usr/local/Cellar/nim/0.19.4/nim/config/nim.cfg' [Conf]
Hint: system [Processing]
Hint: hello_world [Processing]
CC: hello_world
CC: stdlib_system
Hint:  [Link]
Hint: operation successful (12382 lines compiled; 0.660 sec total; 16.383MiB peakmem; Debug Build) [SuccessX]
Hint: /Volumes/pulse/100/Nim/ch01/code/hello_world  [Exec]
Hello world!
\end{lstlisting}
\\
\textbf{Terminal output results}
\\
At this stage I try to understand what the terminal is showing and if I cannot make sense of it, I at least try to find out if my output results is as expected.
\begin{lstlisting}
Hint: used config file '/usr/local/Cellar/nim/0.19.4/nim/config/nim.cfg' [Conf]
		<---- :accessing this directory shows
			  |------ nim.cfg
			  |------ nimdoc.cfg
			  |------ nimdoc.tex.cfg
Hint: system [Processing]
Hint: hello_world [Processing]
CC: hello_world 	<--- looks like Nim is using clang
CC: stdlib_system	<--- looks like Nim is using clang
Hint:  [Link]
Hint: operation successful (12382 lines compiled; 0.660 sec total; 16.383MiB peakmem; Debug Build) [SuccessX] <--- processed Nim packages
Hint: /Volumes/pulse/100/Nim/ch01/code/hello_world  [Exec] <--- script location
Hello world! <--- Expected output
\end{lstlisting}

\textbf{What is in the file/script}

\begin{lstlisting}
In the code repo Nim has created some sort of an object file hello_world (machine code) that Nim (JVM if it is running on it) uses to compile and read the script. Languages such as Java, C, C++ uses such approach (compiled languages). Python does not do such (interpreted language).

$bash: tree -L 1
		hello_world
		hello_world.nim

0 directories, 2 files
\end{lstlisting}

%------------------------------------------------

\subsection{Beginning to learn Nim}

Nim is still a relatively new programming language (first scribbed books ---- Nim in Action, Dominik Picheta).

What should you know going in:
\begin{itemize}
	\item The language is not fully complete
	\item Nim is a general-purpose programming language
	\item effiency, expressiveness and elegance are Nim's standardised priority markers and they rank according to the order mentioned
	\item Nim shares many of Python's characteristics
	\item Nim is a compiled language (translated to C first)
	\item Nim is well suited for systems programming (hardware, OSs, IoT, etc)
	\item Nim is one of the few languages that uses its own language to interpret itself
	\item type system, execution model
	\item Applications that perform I/O operations, such as reading files or sending data over a network, are also well supported by Nim.
	\item Web applications (web frameworks like Jester)
	\item Nim can compile JavaScript
	\item Things that you might be familiar with are covered in Nim (procedures, methods, iterators, generics and templates)
	\item \href{https://github.com/nim-lang/Nim#contributing}{Nim's documentation}
\end{itemize}

\newpage
\subsection{Why should you use Nim}
\begin{description}
	\item[Python, C, C++, ObjC, JavaScript] $\longrightarrow$ Nim's design follows that of Python with the capability to perform foreign interfacing (C, C++, ObjectiveC, JavaScript)
	\item[Nim project started in 2005] $\longrightarrow$  The language is 14 years old, so you will be some sort of an early adopter
	\item[Garbage collector] $\longrightarrow$  Garbage collection + manual memory management
	\item[Game developers] $\longrightarrow$  because of a garbage collector that can be turned on and off this is a useful application for GameDevs
	\item[Scientific computing] $\longrightarrow$  Data Scientists
	\item[Scripting] $\longrightarrow$  Clue codes
	\item[Operating Systems] $\longrightarrow$  Supports Windows, Linux, Unix
	\item[effiency] $\longrightarrow$  Nim focues on compile-time mechanisms (runtime becomes effient)
	\item[Package manager] $\longrightarrow$   Nimble
	\item[Environments to use Nim] $\longrightarrow$  Web applications, Kernel
	\item[Andreas Rumpf] $\longrightarrow$  Andreas Rumpf is the designer of Nimrod programming language, which he develops in his spare time. He is a software engineer working at a top secret company and constantly attempts to create his own start-up which he will allow himself to program in Nimrod full-time. He has programmed in various programming languages over the years (including quite obscure ones) without being satisfied with any of them. Andreas Rumpf holds a degree in Computer Science which he obtained from the University of Kaiserslautern.
\end{description}

\href{https://github.com/nim-lang/Nim#contributing}{The compiler, standard library, and related tools are all open source and written in Nim.}
%------------------------------------------------

\subsection{Core features of Nim}

\begin{enumerate}
	\item Metaprogramming $\longrightarrow$ Read, Generate, Analyze and Transform source code
	\item Style-insensitive $\longrightarrow$ camelCase or snake\_case
	\item Compilation to C $\longrightarrow$ enhances the language's performance
\end{enumerate}

\begin{figure}[h!]
	\includegraphics[width=\linewidth]{compiler.png} % Figure image
	\caption{Compilation backends} % Figure caption
	\label{Nim Compilers} % Label for referencing with \ref{bear}
\end{figure}
\newpage

\subsection{Metaprogramming}

Metaprogramming is the writing of computer programs with the ability to treat programs as their data. It means that a program could be designed to read, generate, analyse and/or transform other programs, and even modify itself while running. \textit{Sounds like stuff from the movies}.  \\

\href{https://hookrace.net/blog/introduction-to-metaprogramming-in-nim/}{HookRace blog}


\begin{itemize}
	\item Normal procs and inline iterators
	\item Generic procs  and closure iterators
	\item Templates
	\item Macros
\end{itemize}

With Nim's metaprogramming capabilities you are able to write domain-specific languages (DSL) shown below in simple few lines.

\begin{lstlisting}
echo("<html>")
echo("  <body>")
echo("    <p>Hello World</p>")
echo("  </body>")
echo("</html>")

output:
<html>
  <body>
    <p>Hello World</p>
  </body>
</html>
\end{lstlisting}


\subsubsection{Normal procs (Functions)}

\begin{lstlisting}
#declare function
proc stationName(station: string) =
			echo "Analyzing " , station, " station"

#call function
stationName("Westergloor")      # f(a)
"Azaadville".stationName        # a.f = f(a)
stationName "Mohlakeng"         # f a

output:
Analyzing Westergloor station
Analyzing Azaadville station
Analyzing Mohlakeng station
\end{lstlisting}

\subsubsection{What does style insensitive mean?}

Notice the use of method to\_upper\(\) and toUpper\(\) executes
the same thing, but adopts snake\_case and camelCase.

\begin{lstlisting}
#style insensitive
import strutils

proc nameFormat(fm: string, name: string) =
  if fm == "Y":
    echo "called toUpper() : " , name.toUpper()
  else:
    echo "called to_upper(): " ,name.to_upper()

nameFormat("Y", "john")
nameFormat("N", "john")

output:
called toUpper() : JOHN
called to_upper(): JOHN
\end{lstlisting}


Nim is a static type system programming language with some dynamic type system interfacing (or supporting) to enable both free-error-proned language and less hindrance to development/writing code. Languages that are dynamically typed are languages like python. Basically, the meaning is that your variables, functions and data structures are not primitively declared or typed to a certain primitive data type (float, int, string, etc). The data assigned to your function will dynamically assign a primitive data type to your function or variable.

\begin{lstlisting}
def array(argument, *args):
    #**args, argument <--not assigned any type
	flag = False
	if argument in args:
		print("Item found")
		flag = True
	else:
		for item in args:
			print(item)
	return flag <--returns a boolean

if __name__ == "__main__":
	#search 1 in 2, 3, 4, 5, 6
	#return false if not found or true if found
	flag = array(1, 2, 3, 4, 5, 6)
	print(flag)
\end{lstlisting}

The code above shows how powerful dynamically typed languages are. However, Nim likes to argue that their static type structure is as powerful unless you employ *ptrs from C that are not so friendly on memory saving. How does Nim take care of its performance? 
\begin{itemize}
	\item Arrays are bounds-checked at compile time, or at runtime when compile-time checks aren’t possible, preventing both buffer overflows and buffer overreads.
	\item Pointer arithmetic isn’t possible for reference types as they’re entirely managed by Nim’s garbage collector; this prevents issues such as dangling pointers and other memory issues related to managing memory manually.
	\item Variables are always initialized by Nim to their default values, which prevents variables containing unexpected and corrupt data.
\end{itemize}

\subsection{Generic Programming}

This is a feature that is rather unique and interesting, the ability to generically chose whether a typed variable can be used as one type or the other. 

\begin{lstlisting}
proc intFloat(number: int | float) =
    echo(number)

intFloat(2)     #f(a)
intFloat 2.2    #f a
3.14.intFloat   #a.f
\end{lstlisting}
\subsection{Foreign language interface}

\subsubsection{nim compile to JavaScript}
\begin{lstlisting}
nim js -d:nodejs [name of script].nim
\end{lstlisting}

Compiling the code creeates a nimcache directory within the current working directory and generates the JavaScript script in it.

\begin{lstlisting}
tree nimcache
nimcache/
		  |__________  fn1.js
\end{lstlisting}

\subsubsection{nim compile to C}



\begin{lstlisting}
nim -c -d:release c fn1
\end{lstlisting}

The converted C code is stored in the home directory under a hidden file (.cache/nim). It is usually assigned the same name as the nim script name with an suffix underscore some letter.

\begin{lstlisting}
bash$: cd $HOME/.cache/nim
tree 
  |______ fn1_r/
    	     	 |__________ fn1.c
		 		 |__________ fn1.json
		 		 |__________ stdlib_system.c
1 directory, 3 files
\end{lstlisting}

\subsubsection{nim compile to ObjectiveC}

\begin{lstlisting}
nim objc --cpu:amd64 --os:macosx --compile_only --gen_script [script name] 
\end{lstlisting}

The converted objective C code is stored in the home directory under a hidden file (.cache/nim). It is usually assigned the same name as the nim script name with an suffix underscore some letter.

\begin{lstlisting}
fn1_d/
		|__________compile_fn1.sh
		|__________fn1.deps
		|__________fn1.json
		|__________fn1.m
		|__________nimbase.h
		|__________stdlib_system.m
\end{lstlisting}

\subsection{Why does Nim compile to C}

The C programming language is very well established as a systems programming language and has been in use for over 40 years. C is one of the most portable pro- gramming languages, with multiple implementations for Windows, Linux, Mac OS, x86, AMD64, ARM, and many other, more obscure OSs and platforms. C compilers sup- port everything from supercomputers to microcontrollers. They’re also very mature and implement many powerful optimizations, which makes C very efficient.
\\
\\
Nim takes advantage of these aspects of C, including its portability, widespread use, and efficiency.
Compiling to C also makes it easy to use existing C and C++ libraries—all you need to do is write some simple wrapper code. You can write this code much faster by using a tool called \textbf{c2nim}. This tool converts C and C++ header files to Nim code, which wraps those files. This is of great benefit because many popular libraries are written in C and C++.

\subsection{Nim's Garbage collector} 

Switching between garbage collectors is easy. You just need to specify the --gc:<gc\_name> flag during compilation and replace <gc\_name> with markandsweep, boehm, or none.


\subsection{Nim's compilation lifecycle} 

\begin{figure}[h!]
	\includegraphics[width=0.8\linewidth]{nim_lifecycle.png} % Figure image
	\caption{Compilation lifecycle} % Figure caption
	\label{Nim Compilers} % Label for referencing with \ref{bear}
\end{figure}

\subsection{Nim benefits} 

\subsubsection{Efficiency} 
\begin{enumerate}
	\item Nim has performance similar to C.
	\item Nim results in software that’s more reliable than software written in C. 
	\item Nim features an improved type system.
	\item Nim supports generics.
	\item Nim implements an advanced form of metaprogramming.
\end{enumerate}

\subsubsection{Where and why I should use Nim} 
\textbf{Picking Nim as a C replacement makes a lot of sense.}

\subsubsection{Nim is clean and readable}

Nim class
\begin{lstlisting}
#class declaration
type
    Dog = object

#class method
proc bark(self: Dog) = echo("Woof!!")

#instantiation
let dog = Dog()
dog.bark()
\end{lstlisting}

Python class 

\begin{lstlisting}
class Dog(object):	#class
    def bark(self):	#class method
        print("Woof!!")

if __name__ == "__main__":
    dog = Dog()	#instantiation
    dog.bark()	   #calling class method

\end{lstlisting}
\newpage
\subsection{Nim simple code snippets}
\begin{lstlisting}
#simple for loop
let list = ["pineapple", "banana", "apple", "orange", "lemon"]

for i in list:
  echo(i)
\end{lstlisting}

\begin{lstlisting}
import strutils

let names = @["John Doe", "John X", "John C"]

var count = 0
for name in names:
    count += 1
    echo("[", count, "] ", name.split[1])

Output:
[1] Doe
[2] X
[3] C
\end{lstlisting}
%-------------------------------------------------------------------------------
%	BIBLIOGRAPHY
%-------------------------------------------------------------------------------

\printbibliography[title={Bibliography}] % Print the bibliography, section title in curly brackets

%------------------------------------------------------------------------------

\end{document}
